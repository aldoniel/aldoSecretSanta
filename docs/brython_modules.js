__BRYTHON__.VFS_timestamp = 1766541740881
if(typeof document !== 'undefined'){
    __BRYTHON__.brython_modules = $B.last(document.getElementsByTagName('script')).src
}
__BRYTHON__.use_VFS = true
var scripts = {"$timestamp": 1766541740881, "RandomClass": [".py", "class Random():\n    \"\"\"\n    https://github.com/yinengy/Mersenne-Twister-in-Python\n    Try to rebuild the pseudo-random algorithm Mersenne Twister, which is used in python's random library.\n    \"\"\"\n    def __init__(self, c_seed=0):\n        # MT19937\n        (self.w, self.n, self.m, self.r) = (32, 624, 397, 31)\n        self.a = 0x9908B0DF\n        (self.u, self.d) = (11, 0xFFFFFFFF)\n        (self.s, self.b) = (7, 0x9D2C5680)\n        (self.t, self.c) = (15, 0xEFC60000)\n        self.l = 18\n        self.f = 1812433253\n        # make a arry to store the state of the generator\n        self.MT = [0 for i in range(self.n)]\n        self.index = self.n+1\n        self.lower_mask = 0x7FFFFFFF\n        self.upper_mask = 0x80000000\n        # inital the seed\n        self.c_seed = c_seed\n        self.seed(c_seed)\n\n    def seed(self, num):\n        \"\"\"initialize the generator from a seed\"\"\"\n        self.MT[0] = num\n        self.index = self.n\n        for i in range(1, self.n):\n            temp = self.f * (self.MT[i-1] ^ (self.MT[i-1] >> (self.w-2))) + i\n            self.MT[i] = temp & 0xffffffff\n\n    def twist(self):\n        \"\"\" Generate the next n values from the series x_i\"\"\"\n        for i in range(0, self.n):\n            x = (self.MT[i] & self.upper_mask) + \\\n                (self.MT[(i+1) % self.n] & self.lower_mask)\n            xA = x >> 1\n            if (x % 2) != 0:\n                xA = xA ^ self.a\n            self.MT[i] = self.MT[(i + self.m) % self.n] ^ xA\n        self.index = 0\n\n    def extract_number(self):\n        \"\"\" Extract a tempered value based on MT[index]\n            calling twist() every n numbers\n        \"\"\"\n        if self.index >= self.n:\n            self.twist()\n\n        y = self.MT[self.index]\n        y = y ^ ((y >> self.u) & self.d)\n        y = y ^ ((y << self.s) & self.b)\n        y = y ^ ((y << self.t) & self.c)\n        y = y ^ (y >> self.l)\n\n        self.index += 1\n        return y & 0xffffffff\n\n    def random(self):\n        \"\"\" return uniform ditribution in [0,1) \"\"\"\n        # a = (self.extract_number() / 10**8) % 1\n        # return float('%.08f' % a)\n        return self.extract_number() / 4294967296  # which is 2**w\n\n    def randint(self, a, b):\n        \"\"\" return random int in [a,b) \"\"\"\n        n = self.random()\n        return int(n/(1/(b-a)) + a)\n\n    def shuffle(self, X):\n        \"\"\" shuffle the sequence \"\"\"\n        newX = list(X)\n        for i in range(10*len(X)):\n            a = self.randint(0, len(X))\n            b = self.randint(0, len(X))\n            newX[a], newX[b] = newX[b], newX[a]\n\n        return newX\n", []], "sys": [".py", "\nfrom _sys import *\n\nimport browser\nimport javascript\n\nclass Error(Exception):\n pass\n \n_getframe=Getframe\n\nabiflags=0\n\ndef audit(event,*args):\n ''\n pass\n \nbrython_debug_mode=__BRYTHON__.debug\n\nbase_exec_prefix=__BRYTHON__.brython_path\n\nbase_prefix=__BRYTHON__.brython_path\n\nbuiltin_module_names=__BRYTHON__.builtin_module_names\n\nbyteorder='little'\n\ndont_write_bytecode=True\n\nexec_prefix=__BRYTHON__.brython_path\n\nexecutable=__BRYTHON__.brython_path+'brython.js'\n\nargv=orig_argv=[__BRYTHON__.script_path]\n\ndef displayhook(value):\n if value is not None :\n  stdout.write(repr(value))\n  \n__displayhook__=displayhook\n\ndef exit(i=None ):\n raise SystemExit('')\n \nclass flag_class:\n\n def __init__(self):\n  self.debug=0\n  self.inspect=0\n  self.interactive=0\n  self.optimize=0\n  self.dont_write_bytecode=0\n  self.no_user_site=0\n  self.no_site=0\n  self.ignore_environment=0\n  self.verbose=0\n  self.bytes_warning=0\n  self.quiet=0\n  self.hash_randomization=1\n  self.isolated=0\n  self.dev_mode=False\n  self.utf8_mode=0\n  self.warn_default_encoding=0\n  \nflags=flag_class()\n\ndef getfilesystemencoding(*args,**kw):\n ''\n\n \n return 'utf-8'\n \ndef getfilesystemencodeerrors():\n return \"utf-8\"\n \ndef intern(string):\n return string\n \nclass int_info:\n bits_per_digit=30\n sizeof_digit=4\n default_max_str_digits=__BRYTHON__.int_max_str_digits\n str_digits_check_threshold=__BRYTHON__.str_digits_check_threshold\n \ndef get_int_max_str_digits():\n return __BRYTHON__.int_max_str_digits\n \ndef set_int_max_str_digits(value):\n try :\n  value=int(value)\n except :\n  raise ValueError(f\"'{value.__class__.__name__}' object \"\n  \"cannot be interpreted as an integer\")\n if value !=0 and value <int_info.str_digits_check_threshold:\n  raise ValueError('maxdigits must be 0 or larger than 640')\n __BRYTHON__.int_max_str_digits=value\n \n \nmaxsize=__BRYTHON__.max_array_size\n\nmaxunicode=1114111\n\nplatform=\"brython\"\n\nplatlibdir=__BRYTHON__.brython_path+'Lib'\n\nprefix=__BRYTHON__.brython_path\n\nstdlib_module_names=frozenset(__BRYTHON__.stdlib_module_names)\n\nversion='.'.join(str(x)for x in __BRYTHON__.version_info[:3])\nversion +=\" (default, %s) \\n[Javascript 1.5] on Brython\"\\\n%__BRYTHON__.compiled_date\nhexversion=0x030800f0\n\nclass _version_info:\n\n def __init__(self,version_info):\n  self.version_info=version_info\n  self.major=version_info[0]\n  self.minor=version_info[1]\n  self.micro=version_info[2]\n  self.releaselevel=version_info[3]\n  self.serial=version_info[4]\n  \n def __getitem__(self,index):\n  if isinstance(self.version_info[index],list):\n   return tuple(self.version_info[index])\n  return self.version_info[index]\n  \n def hexversion(self):\n  try :\n   return '0%d0%d0%d'%(self.major,self.minor,self.micro)\n  finally :\n   return '0%d0000'%(self.major)\n   \n def __str__(self):\n  _s=\"sys.version(major=%d, minor=%d, micro=%d, releaselevel='%s', \"\\\n  \"serial=%d)\"\n  return _s %(self.major,self.minor,self.micro,\n  self.releaselevel,self.serial)\n  \n __repr__=__str__\n \n def __eq__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)==other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ge__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)>=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __gt__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)>other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __le__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)<=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __lt__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)<other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ne__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)!=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n  \n  \nversion_info=_version_info(__BRYTHON__.version_info)\n\nclass SimpleNamespace:\n\n def __init__(self,/,**kwargs):\n  self.__dict__.update(kwargs)\n  \n def __repr__(self):\n  items=(f\"{k}={v!r}\"for k,v in self.__dict__.items())\n  return \"{}({})\".format(\"namespace\",\", \".join(items))\n  \n def __eq__(self,other):\n  if isinstance(self,SimpleNamespace)and isinstance(other,SimpleNamespace):\n   return self.__dict__ ==other.__dict__\n  return NotImplemented\n  \nSimpleNamespace.__module__=\"types\"\n\nvi=_version_info(__BRYTHON__.implementation)\nimplementation=SimpleNamespace(name=\"brython\",\nversion=vi,\nhexversion=vi.hexversion(),\ncache_tag=None )\n\nclass _hash_info:\n\n def __init__(self):\n  self.width=32\n  self.modulus=2147483647\n  self.inf=314159\n  self.nan=0\n  self.imag=1000003\n  self.algorithm='siphash24'\n  self.hash_bits=64\n  self.seed_bits=128\n  cutoff=0\n  \n def __repr__(self):\n \n  return \"sys.hash_info(width=32, modulus=2147483647, inf=314159, \"\\\n  \"nan=0, imag=1000003, algorithm='siphash24', hash_bits=64, \"\\\n  \"seed_bits=128, cutoff=0)\"\n  \nhash_info=_hash_info()\n\nclass _float_info:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self):\n  self.dig=15\n  self.epsilon=2 **-52\n  self.mant_dig=53\n  self.max=__BRYTHON__.MAX_VALUE\n  self.max_exp=2 **10\n  self.max_10_exp=308\n  self.min=__BRYTHON__.MIN_VALUE\n  self.min_exp=-1021\n  self.min_10_exp=-307\n  self.radix=2\n  self.rounds=1\n  self._tuple=(self.max,self.max_exp,self.max_10_exp,self.min,\n  self.min_exp,self.min_10_exp,self.dig,self.mant_dig,self.epsilon,\n  self.radix,self.rounds)\n  \n def __getitem__(self,k):\n  return self._tuple[k]\n  \n def __iter__(self):\n  return iter(self._tuple)\n  \nfloat_info=_float_info()\n\nwarnoptions=[]\n\ndef getfilesystemencoding():\n return 'utf-8'\n \n \n__stdout__=stdout\n__stderr__=stderr\n__stdin__=stdin\n\n__excepthook__=excepthook\n", ["_sys", "javascript", "browser"]], "browser.local_storage": [".py", "\nimport sys\nfrom browser import window,console\n\nhas_local_storage=hasattr(window,'localStorage')\n\nclass _UnProvided():\n pass\n \nclass LocalStorage():\n storage_type=\"local_storage\"\n \n def __init__(self):\n  if not has_local_storage:\n   raise EnvironmentError(\"LocalStorage not available\")\n  self.store=window.localStorage\n  \n def __delitem__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  if key not in self:\n   raise KeyError(key)\n  self.store.removeItem(key)\n  \n def __getitem__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  res=self.store.getItem(key)\n  if res is not None :\n   return res\n  raise KeyError(key)\n  \n def __setitem__(self,key,value):\n  if not isinstance(key,str):\n   raise TypeError(\"key must be string\")\n  if not isinstance(value,str):\n   raise TypeError(\"value must be string\")\n  self.store.setItem(key,value)\n  \n  \n def __contains__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  res=self.store.getItem(key)\n  if res is None :\n   return False\n  return True\n  \n def __iter__(self):\n  keys=self.keys()\n  return keys.__iter__()\n  \n def get(self,key,default=None ):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  return self.store.getItem(key)or default\n  \n def pop(self,key,default=_UnProvided()):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  if type(default)is _UnProvided:\n   ret=self.get(key)\n   del self[key]\n   return ret\n  else :\n   if key in self:\n    ret=self.get(key)\n    del self[key]\n    return ret\n   else :\n    return default\n    \n    \n    \n def keys(self):\n  return [self.store.key(i)for i in range(self.store.length)]\n  \n def values(self):\n  return [self.__getitem__(k)for k in self.keys()]\n  \n def items(self):\n  return list(zip(self.keys(),self.values()))\n  \n def clear(self):\n  self.store.clear()\n  \n def __len__(self):\n  return self.store.length\n  \nif has_local_storage:\n storage=LocalStorage()\n", ["browser.window", "sys", "browser.console", "browser"]], "browser": [".py", "", [], 1], "frenchnamecompressor": [".py", "from browser import window\n\nclass FrenchNameCompressor:\n    def __init__(self):\n        # TOP 300 pr\u00e9noms insee 2023\n        self.top = ['marie-christine', 'jean-fran\u00e7ois', 'marie-th\u00e9r\u00e8se', 'jean-pierre', 'jean-claude', 'jean-michel', 'christophe', 'jacqueline', 'marguerite', 'christiane', 'christelle', 'bernadette', 'anne-marie', 'jean-marie', 'jean-louis', 'emmanuelle', 'antoinette', 'dominique', 'christian', 'fran\u00e7oise', 'catherine', 'madeleine', 'alexandre', 's\u00e9bastien', 'christine', 'st\u00e9phanie', 'v\u00e9ronique', 'guillaume', 'genevi\u00e8ve', 'elisabeth', 'georgette', 'charlotte', 'henriette', 'micheline', 'gabrielle', 'alexandra', 'jean-marc', 'josephine', 'jean-paul', 'pierrette', 'angelique', 'philippe', 'fran\u00e7ois', 'nathalie', 'isabelle', 'fr\u00e9d\u00e9ric', 'st\u00e9phane', 'sandrine', 'marcelle', 'jeannine', 'paulette', 'germaine', 'patricia', 'brigitte', 'laurence', 'juliette', 'virginie', 'lucienne', 'raymonde', 'claudine', 'danielle', 'caroline', 'benjamin', 'florence', 'mathilde', 'emmanuel', 'laetitia', 'b\u00e9atrice', 'mireille', 'delphine', 'michelle', 'jean-luc', 'valentin', 'baptiste', 'jonathan', 'fabienne', 'jocelyne', 'amandine', 'francine', 'huguette', 'cl\u00e9mence', 'fernande', 'matthieu', 'severine', 'aur\u00e9lien', 'jacques', 'bernard', 'nicolas', 'georges', 'monique', 'patrick', 'maurice', 'laurent', 'martine', 'suzanne', 'thierry', 'camille', 'antoine', 'olivier', 'raymond', 'val\u00e9rie', 'charles', 'vincent', 'chantal', 'gabriel', 'aur\u00e9lie', 'mich\u00e8le', 'gilbert', 'th\u00e9r\u00e8se', 'colette', 'cl\u00e9ment', 'anthony', 'francis', 'corinne', 'pauline', 'rapha\u00ebl', 'josette', 'mathieu', 'patrice', 'sylvain', 'fabrice', 'm\u00e9lanie', 'ginette', 'quentin', 'evelyne', 'florian', 'ludovic', 'josiane', 'fernand', 'liliane', 'mickael', 'simonne', 'pascale', 'mohamed', 'sabrina', 'justine', 'yannick', 'solange', 'auguste', 'etienne', 'richard', 'michael', 'vanessa', 'gregory', 'edouard', 'daniele', 'william', 'arlette', 'morgane', 'estelle', 'jessica', 'eug\u00e9nie', 'lucette', 'florent', 'pierre', 'michel', 'jeanne', 'marcel', 'claude', 'daniel', 'robert', 'g\u00e9rard', 'joseph', 'sylvie', 'julien', 'pascal', 'nicole', 'louise', 'h\u00e9l\u00e8ne', 'thomas', 'denise', 'yvonne', 'sophie', 'c\u00e9line', 'didier', 'maxime', 'simone', 'lucien', 'andr\u00e9e', 'albert', 'yvette', 'emilie', 'romain', 'odette', 'jerome', 'c\u00e9cile', 'franck', 'gilles', 'claire', 'elodie', 'alexis', 'audrey', 'adrien', 'gis\u00e8le', 'arthur', 'arnaud', 'victor', 'cedric', 'roland', 'nadine', 'annick', 'damien', 'beno\u00eet', 'marion', 'marthe', 'karine', 'nathan', 'marine', 'jeremy', 'eliane', 'xavier', 'fabien', 'eug\u00e8ne', 'carole', 'sandra', 'myriam', 'am\u00e9lie', 'samuel', 'gaston', 'jo\u00eblle', 'lionel', 'maryse', 'marius', 'mathis', 'oc\u00e9ane', 'magali', 'ang\u00e8le', 'muriel', 'berthe', 'martin', 'marie', 'andr\u00e9', 'louis', 'alain', 'roger', 'henri', 'david', 'ren\u00e9e', 'bruno', 'serge', 'julie', 'annie', 'lucie', 'alice', 'lucas', 'sarah', 'manon', 'jules', 'emile', 'chlo\u00e9', 'denis', 'kevin', 'laura', 'maria', 'herv\u00e9', 'ana\u00efs', 'elise', 'agn\u00e8s', 'clara', 'odile', 'simon', 'aline', 'cyril', 'ir\u00e8ne', 'sonia', 'laure', 'fanny', 'julia', 'nadia', 'ethan', 'nelly', 'jean', 'ren\u00e9', 'paul', 'anne', 'eric', 'marc', 'yves', 'emma', 'hugo', 'jo\u00ebl', 'l\u00e9on', 'th\u00e9o', 'anna', 'enzo', 'rose', 'lo\u00efc', 'jade', 'in\u00e8s', 'r\u00e9mi', 'axel', 'yann', 'adam', 'lola', 'r\u00e9my', 'lina', 'guy', 'l\u00e9a', 'l\u00e9o', 'tom', 'eva']\n\n        # mapping rapide name -> index\n        self.name_to_index = {name: i for i, name in enumerate(self.top)}\n\n        # choisir la fonction d'\u00e9chappement : RegExp.escape si disponible, sinon fallback\n        if hasattr(window.RegExp, \"escape\"):\n            esc_fn = window.RegExp.escape\n        else:\n            esc_fn = self._escape_for_js_regex\n\n        # construire alternation \u00e9chapp\u00e9e\n        escaped_names = [esc_fn(name) for name in self.top]\n        alternation = '|'.join(escaped_names)\n        self.pattern_str = r'(' + alternation + r')'\n        # RegExp JS global (g). Pas d'i car tout est en lower-case.\n        self.pattern_re = window.RegExp.new(self.pattern_str, \"g\")\n        self.decomp_re = window.RegExp.new(r'([A-Z]{2})', \"g\")\n\n    @staticmethod\n    def _escape_for_js_regex(s):\n        # fallback simple pour \u00e9chapper les m\u00e9tacaract\u00e8res regex en JS\n        specials = r\"\\^$.|?*+()[]{}\\/\"\n        out = []\n        for ch in s:\n            if ch in specials:\n                out.append('\\\\' + ch)\n            else:\n                out.append(ch)\n        return ''.join(out)\n\n    @staticmethod\n    def _encode(n):\n        a = n // 26\n        b = n % 26\n        orda=ord('A')\n        return chr(orda + a) + chr(orda + b)\n\n    @staticmethod\n    def _decode(code):\n        orda=ord('A')\n        return (ord(code[0]) - orda) * 26 + (ord(code[1]) - orda)\n\n    def compress(self, liste_prenoms):\n        \"\"\"Remplace chaque pr\u00e9nom (d\u00e9j\u00e0 en lower-case) par xy en utilisant RegExp JS.\"\"\"\n        def repl_js(*args):\n            # args[1] = groupe captur\u00e9 (le pr\u00e9nom)\n            name = str(args[1]) if len(args) >= 2 else str(args[0])\n            idx = self.name_to_index.get(name)\n            return self._encode(idx) if idx is not None else str(args[0])\n\n        out = []\n        for s in liste_prenoms:\n            js_str = window.String.new(s)\n            replaced = js_str.replace(self.pattern_re, repl_js)\n            out.append(str(replaced))\n        return out\n\n    def decompress(self, compressed):\n        \"\"\"Remplace chaque xy par le pr\u00e9nom correspondant en utilisant RegExp JS.\"\"\"\n        def repl_code_js(*args):\n            code = str(args[1])\n            idx = self._decode(code)\n            return self.top[idx] if 0 <= idx < len(self.top) else str(args[0])\n\n        out = []\n        for s in compressed:\n            js_str = window.String.new(s)\n            replaced = js_str.replace(self.decomp_re, repl_code_js)\n            out.append(str(replaced))\n        return out\n\n\n# Exemple d'utilisation en Brython\ndef test():\n    comp = FrenchNameCompressor()\n    src = [\"alice\", \"bob le chat\", \"jeanne\", \"momohamed\", \"mohamed\",\"jean pierre\", \"marc lavoine\"]\n    c = comp.compress(src)\n    print(f\"{src=}\")\n    print(\"compress:\", c)\n    print(\"decompress:\", comp.decompress(c))\n\ntest()\n", ["browser.window", "browser"]]}
__BRYTHON__.update_VFS(scripts)